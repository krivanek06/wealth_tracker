datasource db {
    provider = "mongodb"
    url      = env("DATABASE_URL")
}

generator client {
    provider = "prisma-client-js"
}

model User {
    id             String   @id @default(auto()) @map("_id") @db.ObjectId
    createdAt      DateTime @default(now())
    imageUrl       String?
    username       String   @unique
    email          String   @unique
    lastSingInDate DateTime @default(now())

    // how user created his account
    authentication UserAuthentication

    // 1 - 1 relationship with user tags
    // one user can craete multiple tags
    PersonalAccountTags PersonalAccountTag[]

    // 1 - N relationship with multiple investment accounts
    // one user can craete multiple investment accounts
    InvestmentAccounts InvestmentAccount[]

    // 1 - N relationship with multiple personal accounts
    // one user can craete multiple personal accounts
    PersonalAccounts PersonalAccount[]
}

type UserAuthentication {
    authenticationType AuthenticationType

    // Used for social media atuehntication
    token String?

    // used for basic authentication 
    password String?
}

enum AuthenticationType {
    BASIC_AUTH
    GOOGLE
}

// ---------------- Personal account ------------------

model PersonalAccount {
    id        String   @id @default(auto()) @map("_id") @db.ObjectId
    name      String
    createdAt DateTime @default(now())

    // 1 - N reference with PersonalAccountMonthlyData
    MonthlyData PersonalAccountMonthlyData[]

    // 1 - N relationship with user
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId String @db.ObjectId

    // 1 - N relationship with PersonalAccountTag
    PersonalAccountTag PersonalAccountTag[]
}

model PersonalAccountTag {
    id         String                     @id @default(auto()) @map("_id") @db.ObjectId
    createdAt  DateTime                   @default(now())
    modifiedAt DateTime                   @updatedAt
    name       String // custom name for personal account
    type       PersonalAccountTagDataType

    // True only for default Tags - by admin
    isDefault Boolean @default(false)

    // N - 1 relationship with user 
    // user who created the tag
    user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId String? @unique

    // N - 1 relationship with PersonalAccount
    // Used to display this Tag only for one specific account 
    PersonalAccounSpecific PersonalAccount? @relation(fields: [personalAccountId], references: [id])
    personalAccountId      String?          @unique
}

enum PersonalAccountTagDataType {
    INCOME
    EXPENSE
}

// Created by cloud functions that runs once per month
model PersonalAccountMonthlyData {
    id    String @id @default(auto()) @map("_id") @db.ObjectId
    month Int // 8 == 'September', 0 == 'Januar',
    year  Int // 2022

    // daily entries of user's expenses / incomes - changed on user's input
    dailyData PersonalAccountDailyData[]

    // N - 1 reference to PersonalAccount
    PersonalAccount   PersonalAccount @relation(fields: [personalAccountId], references: [id], onDelete: Cascade)
    personalAccountId String          @db.ObjectId
}

type PersonalAccountDailyData {
    id     String   @default(uuid()) // random
    tagId  String // ID of TagData -> Can be modified, resolved on the FE!
    value  Float // $ how much I paid / received
    date   DateTime @default(now())
    week   Int // Week 37 <- calculate on DB update
    userId String // user who created the daily entry
}

// ---------------- Investment account ------------------
model InvestmentAccount {
    id          String @id @default(auto()) @map("_id") @db.ObjectId
    name        String // custom name for personal account
    cashCurrent Float // how much cash on hand user has in the trading platform

    holdings              InvestmentAccountHoldings[]
    lastPortfolioSnapshot InvestmentAccountPortfolioSnapshot // last inserted value in InvestmentAccountSnapshots[-1]

    // 1 - N relationship with user
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId String @db.ObjectId

    // 1 - N relationship with InvestmentAccountSnapshots
    InvestmentAccountHistory   InvestmentAccountHistory @relation(fields: [investmentAccountHistoryId], references: [id], onDelete: Cascade)
    investmentAccountHistoryId String                   @unique
}

model InvestmentAccountHistory {
    id String @id @default(auto()) @map("_id") @db.ObjectId

    portfolioSnapshotTotal Int
    portfolioSnapshots     InvestmentAccountPortfolioSnapshot[]

    // 1 - N relationship with InvestmentAccount
    InvestmentAccount InvestmentAccount?
}

type InvestmentAccountHoldings {
    symbol            String // ID of symbol in DB in Firestore -> AAPL, MSFT
    type              InvestmentAccountHoldingsType
    units             Float // how many units of asset the user have
    investmentStarted Float // $ how much user invested into a specific asset
}

enum InvestmentAccountHoldingsType {
    STOCK
    CRYPTO
}

type InvestmentAccountPortfolioSnapshot {
    id                String   @default(uuid()) // random
    date              DateTime
    cash              Float // user input
    investmentCurrent Float // current price of assets * units
}
